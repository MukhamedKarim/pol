<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <title>Метод Полларда (ρ) — Дискретный логарифм</title>
  <style>
    body {
      font-family: sans-serif;
      max-width: 640px;
      margin: 40px auto;
      padding: 0 20px;
    }
    input, button {
      padding: 8px;
      margin-top: 10px;
      width: 100%;
      font-size: 16px;
    }
    .output {
      background: #f5f5f5;
      padding: 10px;
      margin-top: 10px;
      white-space: pre-wrap;
      max-height: 400px;
      overflow-y: auto;
      border-radius: 12px;
      border: 2px solid transparent;
      box-shadow: 0 0 10px rgba(255, 200, 0, 0.3);
      animation: glow-border 2.5s ease-in-out infinite alternate;
    }
    @keyframes glow-border {
      0% {
        border-color: rgba(255, 200, 0, 0.3);
        box-shadow: 0 0 10px rgba(255, 200, 0, 0.3);
      }
      100% {
        border-color: rgba(255, 180, 0, 0.8);
        box-shadow: 0 0 20px rgba(255, 180, 0, 0.8);
      }
    }
    .success {
      background: #e0ffe0;
      border: 1px solid #66cc66;
    }
    .error {
      background: #ffe0e0;
      border: 1px solid #cc6666;
    }
    .info-box {
      background-color: #eaf4ff;
      border-left: 5px solid #3399ff;
      padding: 10px 15px;
      margin: 15px 0 25px;
      border-radius: 10px;
      font-size: 15px;
      line-height: 1.5;
    }
  </style>
</head>
<body>
  <h1>Метод Полларда (ρ) для дискретного логарифма</h1>
  <div class="info-box">
    <strong>ℹ Что делает эта программа?</strong><br>
    Находит x, такое что g<sup>x</sup> ≡ h (mod p),<br>
    с помощью стохастического алгоритма Полларда ρ (цепочки со встречей).
  </div>
  <input type="text" id="g" placeholder="Основание g" value="5">
  <input type="text" id="h" placeholder="Значение h = g^x mod p" value="3441">
  <input type="text" id="p" placeholder="Модуль p (простое число)" value="10007">
  <button onclick="runLogarithm()">Найти логарифм</button>
  <button onclick="repeatAttempt()">Повторить попытку</button>
  <div class="output" id="log-output"></div>

  <script>
    // Наибольший общий делитель (используется для проверки обратимости)
    function gcd(a, b) {
      while (b !== 0n) [a, b] = [b, a % b];
      return a;
    }

    // Быстрое возведение в степень по модулю
    function modPow(base, exp, mod) {
      let result = 1n;
      base = BigInt(base) % mod;
      exp = BigInt(exp);
      while (exp > 0n) {
        if (exp % 2n === 1n) result = (result * base) % mod;
        base = (base * base) % mod;
        exp /= 2n;
      }
      return result;
    }

    // Обратный элемент по модулю (используется при нахождении логарифма)
    function modInverse(a, mod) {
      let m0 = mod, x0 = 0n, x1 = 1n;
      if (mod === 1n) return 0n;
      a = a % mod;
      while (a > 1n) {
        let q = a / mod;
        [a, mod] = [mod, a % mod];
        [x0, x1] = [x1 - q * x0, x0];
      }
      return x1 < 0n ? x1 + m0 : x1;
    }

    // Алгоритм Полларда ρ для дискретного логарифма
    function pollardsRhoLog(g, h, p, maxIter = 100000) {
      const n = p - 1n; // порядок мультипликативной группы
      let a = 0n, b = 0n, A = 0n, B = 0n; // счетчики для x и X
      let x = 1n, X = 1n; // начальные значения двух последовательностей
      const log = [`Начало алгоритма при g = ${g}, h = ${h}, p = ${p}`];

      // Разделение на три подмножества (итерационная функция)
      const f = (val, a, b) => {
        const r = val % 3n;
        if (r === 0n) {
          val = (val * g) % p;
          a = (a + 1n) % n;
        } else if (r === 1n) {
          val = (val * h) % p;
          b = (b + 1n) % n;
        } else {
          val = (val * val) % p;
          a = (2n * a) % n;
          b = (2n * b) % n;
        }
        return [val, a, b];
      };

      // Основной цикл алгоритма
      for (let i = 1; i <= maxIter; i++) {
        [x, a, b] = f(x, a, b);          // медленная цепочка
        [X, A, B] = f(...f(X, A, B));    // быстрая цепочка (2 шага)

        // лог текущих значений
        log.push(`Итерация ${i}: x = ${x}, X = ${X}, a = ${a}, A = ${A}, b = ${b}, B = ${B}`);

        // При совпадении элементов двух цепочек
        if (x === X) {
          const r = (a - A + n) % n;
          const s = (B - b + n) % n;
          log.push(`Найдено совпадение: x = X = ${x}`);
          if (s === 0n || gcd(s, n) !== 1n) {
            log.push(`s = ${s} не пригоден для обращения. Повторить попытку.`);
            return { x: null, log };
          }
          const sInv = modInverse(s, n); // обращение s
          const result = (r * sInv) % n; // вычисление логарифма
          log.push(`Вычислен результат: x = ${result}`);
          return { x: result, log };
        }
      }

      // Если не найдено за отведенное число итераций
      log.push("Дискретный логарифм не найден за максимальное число итераций.");
      return { x: null, log };
    }

    // Запуск алгоритма по нажатию кнопки
    function runLogarithm() {
      const g = BigInt(document.getElementById("g").value);
      const h = BigInt(document.getElementById("h").value);
      const p = BigInt(document.getElementById("p").value);
      const output = document.getElementById("log-output");
      output.innerHTML = "";

      // Проверка на валидность входных данных
      if (p <= 1n || g <= 0n || h < 0n || g >= p || h >= p) {
        output.innerHTML = "<div class='error'>Неверные входные данные</div>";
        return;
      }

      try {
        const { x, log } = pollardsRhoLog(g, h, p);
        if (x !== null && modPow(g, x, p) === h) {
          output.innerHTML = `<div class='success'>Найден x: ${x}</div><br><strong>Лог:</strong><br>` + log.join("\n");
        } else {
          output.innerHTML = `<div class='error'>x не найден</div><br><strong>Лог:</strong><br>` + log.join("\n");
        }
      } catch (e) {
        output.innerHTML = `<div class='error'>Ошибка: ${e.message}</div>`;
      }
    }

    // Повторная попытка с новыми случайными g, x, h
    function repeatAttempt() {
      const p = BigInt(document.getElementById("p").value);
      // g случайное от 2 до p - 2
      const g = BigInt(2n + BigInt(Math.floor(Math.random() * Number(p - 3n))));
      // x случайное от 1 до p - 2
      const x = BigInt(1n + BigInt(Math.floor(Math.random() * Number(p - 2n))));
      // h = g^x mod p
      const h = modPow(g, x, p);

      document.getElementById("g").value = g;
      document.getElementById("h").value = h;

      const output = document.getElementById("log-output");
      // Показать сгенерированное x пользователю
      output.innerHTML = `<div class='info-box'>Случайно сгенерированное значение x: ${x}</div>`;

      runLogarithm();
    }
  </script>
</body>
</html>
